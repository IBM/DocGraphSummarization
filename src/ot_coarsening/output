Processing...
Done!
iteration
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
     376.56M        434.00M   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       2.51G          2.56G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       1.79G          2.56G   60     if (gpu & torch.cuda.is_available()):                                                              
       1.79G          2.56G   61         C = C.cuda()                                                                                   
       1.79G          2.56G   62         mu = mu.cuda()                                                                                 
       1.79G          2.56G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       1.79G          2.56G   66     tau = -.8  # nesterov-like acceleration                                                            
       1.79G          2.56G   67     thresh = acc  # stopping criterion                                                                 
       1.79G          2.56G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       1.79G          2.56G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       1.79G          2.56G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       1.79G          2.56G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       1.79G          2.56G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       1.79G          2.56G   88     u.requires_grad = True                                                                             
       1.79G          2.56G   89     v.requires_grad = True                                                                             
       1.79G          2.56G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       1.81G          2.59G   92     for i in range(niter):                                                                             
       1.81G          2.58G   93         u1 = u  # useful to check the update                                                           
       1.81G          2.58G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       1.81G          2.58G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       1.81G          2.59G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       1.81G          2.59G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       1.81G          2.59G  103         actual_nits += 1                                                                               
       1.81G          2.59G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       1.81G          2.59G  106     U, V = u, v                                                                                        
       1.82G          2.59G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       1.81G          2.59G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       1.81G          2.59G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
     376.56M        434.00M   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
     376.56M        434.00M   19     n = x.size()[0]                                                            
     376.56M        434.00M   20     m = y.size()[0]                                                            
     376.56M        434.00M   21     mu = torch.ones(n)/n                                                       
     376.56M        434.00M   22     nu = torch.ones(m)/m                                                       
       2.51G          2.59G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       1.81G          2.59G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G          3.68G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G          3.68G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G          3.68G   61         C = C.cuda()                                                                                   
       2.91G          3.68G   62         mu = mu.cuda()                                                                                 
       2.91G          3.68G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G          3.68G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G          3.68G   67     thresh = acc  # stopping criterion                                                                 
       2.91G          3.68G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G          3.68G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G          3.68G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G          3.68G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G          3.68G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G          3.68G   88     u.requires_grad = True                                                                             
       2.91G          3.68G   89     v.requires_grad = True                                                                             
       2.91G          3.68G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G          3.70G   92     for i in range(niter):                                                                             
       2.92G          3.70G   93         u1 = u  # useful to check the update                                                           
       2.92G          3.70G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G          3.70G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G          3.70G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G          3.70G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G          3.70G  103         actual_nits += 1                                                                               
       2.92G          3.70G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G          3.70G  106     U, V = u, v                                                                                        
       2.92G          3.70G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G          3.70G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G          3.70G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       1.81G          2.59G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       1.81G          2.59G   19     n = x.size()[0]                                                            
       1.81G          2.59G   20     m = y.size()[0]                                                            
       1.81G          2.59G   21     mu = torch.ones(n)/n                                                       
       1.81G          2.59G   22     nu = torch.ones(m)/m                                                       
       3.45G          3.70G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     278.62M        312.00M  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     278.62M        312.00M  109         x, adj, mask = data.x, data.adj, data.mask                                         
     278.63M        312.00M  110         batch_num_nodes = data.mask.sum(-1)                                                
     302.01M        332.00M  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     341.18M        394.00M  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     341.17M        394.00M  114         xs = [coarse_x.mean(dim=1)]                                                        
     382.32M        434.00M  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     375.82M        434.00M  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     375.82M        434.00M  118         opt_loss = 0.0                                                                     
       2.92G          3.70G  119         for i in range(len(x)):                                                            
       1.81G          2.59G  120             x3 = self.get_nonzero_rows(x[i])                                               
       1.81G          2.59G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       3.45G          3.70G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       2.92G          3.70G  126             del x3                                                                         
       2.92G          3.70G  127             del x4                                                                         
       2.92G          3.70G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       1.81G          6.22G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G          6.22G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G          6.22G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G          6.22G   61         C = C.cuda()                                                                                   
       2.91G          6.22G   62         mu = mu.cuda()                                                                                 
       2.91G          6.22G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G          6.22G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G          6.22G   67     thresh = acc  # stopping criterion                                                                 
       2.91G          6.22G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G          6.22G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G          6.22G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G          6.22G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G          6.22G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G          6.22G   88     u.requires_grad = True                                                                             
       2.91G          6.22G   89     v.requires_grad = True                                                                             
       2.91G          6.22G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G          6.22G   92     for i in range(niter):                                                                             
       2.92G          6.22G   93         u1 = u  # useful to check the update                                                           
       2.92G          6.22G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G          6.22G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G          6.22G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G          6.22G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G          6.22G  103         actual_nits += 1                                                                               
       2.92G          6.22G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G          6.22G  106     U, V = u, v                                                                                        
       2.92G          6.22G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G          6.22G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G          6.22G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       1.81G          6.22G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       1.81G          6.22G   19     n = x.size()[0]                                                            
       1.81G          6.22G   20     m = y.size()[0]                                                            
       1.81G          6.22G   21     mu = torch.ones(n)/n                                                       
       1.81G          6.22G   22     nu = torch.ones(m)/m                                                       
       3.45G          6.22G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       1.81G          6.22G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G          6.22G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G          6.22G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G          6.22G   61         C = C.cuda()                                                                                   
       2.91G          6.22G   62         mu = mu.cuda()                                                                                 
       2.91G          6.22G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G          6.22G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G          6.22G   67     thresh = acc  # stopping criterion                                                                 
       2.91G          6.22G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G          6.22G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G          6.22G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G          6.22G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G          6.22G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G          6.22G   88     u.requires_grad = True                                                                             
       2.91G          6.22G   89     v.requires_grad = True                                                                             
       2.91G          6.22G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G          6.22G   92     for i in range(niter):                                                                             
       2.92G          6.22G   93         u1 = u  # useful to check the update                                                           
       2.92G          6.22G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G          6.22G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G          6.22G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G          6.22G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G          6.22G  103         actual_nits += 1                                                                               
       2.92G          6.22G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G          6.22G  106     U, V = u, v                                                                                        
       2.92G          6.22G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G          6.22G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G          6.22G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       1.81G          6.22G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       1.81G          6.22G   19     n = x.size()[0]                                                            
       1.81G          6.22G   20     m = y.size()[0]                                                            
       1.81G          6.22G   21     mu = torch.ones(n)/n                                                       
       1.81G          6.22G   22     nu = torch.ones(m)/m                                                       
       3.45G          6.22G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     302.89M          6.22G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     302.89M          6.22G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     302.91M          6.22G  110         batch_num_nodes = data.mask.sum(-1)                                                
     326.28M          6.22G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     365.45M          6.22G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     365.44M          6.22G  114         xs = [coarse_x.mean(dim=1)]                                                        
     406.60M          6.22G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     400.75M          6.22G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     400.75M          6.22G  118         opt_loss = 0.0                                                                     
       2.92G          6.22G  119         for i in range(len(x)):                                                            
       1.81G          6.22G  120             x3 = self.get_nonzero_rows(x[i])                                               
       1.81G          6.22G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       3.45G          6.22G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       2.92G          6.22G  126             del x3                                                                         
       2.92G          6.22G  127             del x4                                                                         
       2.92G          6.22G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       1.81G          6.22G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G          8.76G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G          8.76G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G          8.76G   61         C = C.cuda()                                                                                   
       2.91G          8.76G   62         mu = mu.cuda()                                                                                 
       2.91G          8.76G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G          8.76G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G          8.76G   67     thresh = acc  # stopping criterion                                                                 
       2.91G          8.76G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G          8.76G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G          8.76G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G          8.76G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G          8.76G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G          8.76G   88     u.requires_grad = True                                                                             
       2.91G          8.76G   89     v.requires_grad = True                                                                             
       2.91G          8.76G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G          8.76G   92     for i in range(niter):                                                                             
       2.92G          8.76G   93         u1 = u  # useful to check the update                                                           
       2.92G          8.76G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G          8.76G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G          8.76G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G          8.76G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G          8.76G  103         actual_nits += 1                                                                               
       2.92G          8.76G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G          8.76G  106     U, V = u, v                                                                                        
       2.92G          8.76G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G          8.76G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G          8.76G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       1.81G          6.22G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       1.81G          6.22G   19     n = x.size()[0]                                                            
       1.81G          6.22G   20     m = y.size()[0]                                                            
       1.81G          6.22G   21     mu = torch.ones(n)/n                                                       
       1.81G          6.22G   22     nu = torch.ones(m)/m                                                       
       3.45G          8.76G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G          8.76G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G          8.76G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G          8.76G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G          8.76G   61         C = C.cuda()                                                                                   
       2.91G          8.76G   62         mu = mu.cuda()                                                                                 
       2.91G          8.76G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G          8.76G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G          8.76G   67     thresh = acc  # stopping criterion                                                                 
       2.91G          8.76G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G          8.76G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G          8.76G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G          8.76G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G          8.76G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G          8.76G   88     u.requires_grad = True                                                                             
       2.91G          8.76G   89     v.requires_grad = True                                                                             
       2.91G          8.76G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G          8.76G   92     for i in range(niter):                                                                             
       2.92G          8.76G   93         u1 = u  # useful to check the update                                                           
       2.92G          8.76G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G          8.76G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G          8.76G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G          8.76G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G          8.76G  103         actual_nits += 1                                                                               
       2.92G          8.76G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G          8.76G  106     U, V = u, v                                                                                        
       2.92G          8.76G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G          8.76G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G          8.76G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G          8.76G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G          8.76G   19     n = x.size()[0]                                                            
       2.12G          8.76G   20     m = y.size()[0]                                                            
       2.12G          8.76G   21     mu = torch.ones(n)/n                                                       
       2.12G          8.76G   22     nu = torch.ones(m)/m                                                       
       3.45G          8.76G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     302.90M          6.22G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     302.90M          6.22G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     302.92M          6.22G  110         batch_num_nodes = data.mask.sum(-1)                                                
     326.29M          6.22G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     365.46M          6.22G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     365.45M          6.22G  114         xs = [coarse_x.mean(dim=1)]                                                        
     406.60M          6.22G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     400.75M          6.22G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     400.75M          6.22G  118         opt_loss = 0.0                                                                     
       2.92G          8.76G  119         for i in range(len(x)):                                                            
       2.12G          8.76G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.12G          8.76G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       3.45G          8.76G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       2.92G          8.76G  126             del x3                                                                         
       2.92G          8.76G  127             del x4                                                                         
       2.92G          8.76G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     302.90M         10.46G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     302.90M         10.46G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     302.92M         10.46G  110         batch_num_nodes = data.mask.sum(-1)                                                
     326.29M         10.46G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     365.46M         10.46G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     365.45M         10.46G  114         xs = [coarse_x.mean(dim=1)]                                                        
     406.60M         10.46G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     400.75M         10.46G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     400.75M         10.46G  118         opt_loss = 0.0                                                                     
       2.92G         10.46G  119         for i in range(len(x)):                                                            
       2.12G         10.46G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.12G         10.46G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       3.45G         10.46G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       2.92G         10.46G  126             del x3                                                                         
       2.92G         10.46G  127             del x4                                                                         
       2.92G         10.46G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     302.90M         10.46G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     302.90M         10.46G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     302.92M         10.46G  110         batch_num_nodes = data.mask.sum(-1)                                                
     326.29M         10.46G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     365.46M         10.46G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     365.45M         10.46G  114         xs = [coarse_x.mean(dim=1)]                                                        
     406.60M         10.46G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     400.75M         10.46G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     400.75M         10.46G  118         opt_loss = 0.0                                                                     
       2.92G         10.46G  119         for i in range(len(x)):                                                            
       2.12G         10.46G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.12G         10.46G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       3.45G         10.46G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       2.92G         10.46G  126             del x3                                                                         
       2.92G         10.46G  127             del x4                                                                         
       2.92G         10.46G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     302.90M         10.46G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     302.90M         10.46G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     302.92M         10.46G  110         batch_num_nodes = data.mask.sum(-1)                                                
     326.29M         10.46G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     365.46M         10.46G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     365.45M         10.46G  114         xs = [coarse_x.mean(dim=1)]                                                        
     406.60M         10.46G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     400.75M         10.46G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     400.75M         10.46G  118         opt_loss = 0.0                                                                     
       2.92G         10.46G  119         for i in range(len(x)):                                                            
       2.12G         10.46G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.12G         10.46G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       3.45G         10.46G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       2.92G         10.46G  126             del x3                                                                         
       2.92G         10.46G  127             del x4                                                                         
       2.92G         10.46G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     302.90M         10.46G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     302.90M         10.46G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     302.92M         10.46G  110         batch_num_nodes = data.mask.sum(-1)                                                
     326.29M         10.46G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     365.46M         10.46G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     365.45M         10.46G  114         xs = [coarse_x.mean(dim=1)]                                                        
     406.60M         10.46G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     400.75M         10.46G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     400.75M         10.46G  118         opt_loss = 0.0                                                                     
       2.92G         10.46G  119         for i in range(len(x)):                                                            
       2.12G         10.46G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.12G         10.46G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       3.45G         10.46G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       2.92G         10.46G  126             del x3                                                                         
       2.92G         10.46G  127             del x4                                                                         
       2.92G         10.46G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.45G         10.46G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         10.46G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         10.46G   61         C = C.cuda()                                                                                   
       2.91G         10.46G   62         mu = mu.cuda()                                                                                 
       2.91G         10.46G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         10.46G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         10.46G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         10.46G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         10.46G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         10.46G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         10.46G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         10.46G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         10.46G   88     u.requires_grad = True                                                                             
       2.91G         10.46G   89     v.requires_grad = True                                                                             
       2.91G         10.46G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         10.46G   92     for i in range(niter):                                                                             
       2.92G         10.46G   93         u1 = u  # useful to check the update                                                           
       2.92G         10.46G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         10.46G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         10.46G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         10.46G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         10.46G  103         actual_nits += 1                                                                               
       2.92G         10.46G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         10.46G  106     U, V = u, v                                                                                        
       2.92G         10.46G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         10.46G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         10.46G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.45G         10.46G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     302.90M         10.46G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     302.90M         10.46G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     302.92M         10.46G  110         batch_num_nodes = data.mask.sum(-1)                                                
     326.29M         10.46G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     365.46M         10.46G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     365.45M         10.46G  114         xs = [coarse_x.mean(dim=1)]                                                        
     406.60M         10.46G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     400.75M         10.46G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     400.75M         10.46G  118         opt_loss = 0.0                                                                     
       2.92G         10.46G  119         for i in range(len(x)):                                                            
       2.12G         10.46G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.12G         10.46G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       3.45G         10.46G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       2.92G         10.46G  126             del x3                                                                         
       2.92G         10.46G  127             del x4                                                                         
       2.92G         10.46G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.12G         10.46G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       3.79G         13.86G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       2.91G         13.86G   60     if (gpu & torch.cuda.is_available()):                                                              
       2.91G         13.86G   61         C = C.cuda()                                                                                   
       2.91G         13.86G   62         mu = mu.cuda()                                                                                 
       2.91G         13.86G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       2.91G         13.86G   66     tau = -.8  # nesterov-like acceleration                                                            
       2.91G         13.86G   67     thresh = acc  # stopping criterion                                                                 
       2.91G         13.86G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       2.91G         13.86G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       2.91G         13.86G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       2.91G         13.86G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       2.91G         13.86G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       2.91G         13.86G   88     u.requires_grad = True                                                                             
       2.91G         13.86G   89     v.requires_grad = True                                                                             
       2.91G         13.86G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       2.92G         13.86G   92     for i in range(niter):                                                                             
       2.92G         13.86G   93         u1 = u  # useful to check the update                                                           
       2.92G         13.86G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       2.92G         13.86G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       2.92G         13.86G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       2.92G         13.86G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       2.92G         13.86G  103         actual_nits += 1                                                                               
       2.92G         13.86G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       2.92G         13.86G  106     U, V = u, v                                                                                        
       2.92G         13.86G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       2.92G         13.86G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       2.92G         13.86G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.12G         10.46G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.12G         10.46G   19     n = x.size()[0]                                                            
       2.12G         10.46G   20     m = y.size()[0]                                                            
       2.12G         10.46G   21     mu = torch.ones(n)/n                                                       
       2.12G         10.46G   22     nu = torch.ones(m)/m                                                       
       3.79G         13.86G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         13.86G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         13.86G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         13.86G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         13.86G   61         C = C.cuda()                                                                                   
       4.11G         13.86G   62         mu = mu.cuda()                                                                                 
       4.11G         13.86G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         13.86G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         13.86G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         13.86G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         13.86G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         13.86G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         13.86G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         13.86G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         13.86G   88     u.requires_grad = True                                                                             
       4.11G         13.86G   89     v.requires_grad = True                                                                             
       4.11G         13.86G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         13.86G   92     for i in range(niter):                                                                             
       4.12G         13.86G   93         u1 = u  # useful to check the update                                                           
       4.12G         13.86G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         13.86G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         13.86G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         13.86G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         13.86G  103         actual_nits += 1                                                                               
       4.12G         13.86G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         13.86G  106     U, V = u, v                                                                                        
       4.13G         13.86G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         13.86G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         13.86G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         13.86G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         13.86G   19     n = x.size()[0]                                                            
       2.70G         13.86G   20     m = y.size()[0]                                                            
       2.70G         13.86G   21     mu = torch.ones(n)/n                                                       
       2.70G         13.86G   22     nu = torch.ones(m)/m                                                       
       4.81G         13.86G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     303.78M         10.46G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     303.78M         10.46G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     303.80M         10.46G  110         batch_num_nodes = data.mask.sum(-1)                                                
     327.18M         10.46G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     366.35M         10.46G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     366.34M         10.46G  114         xs = [coarse_x.mean(dim=1)]                                                        
     406.84M         10.46G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     400.99M         10.46G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     400.99M         10.46G  118         opt_loss = 0.0                                                                     
       4.12G         13.86G  119         for i in range(len(x)):                                                            
       2.70G         13.86G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         13.86G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         13.86G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         13.86G  126             del x3                                                                         
       4.12G         13.86G  127             del x4                                                                         
       4.12G         13.86G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.40M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.40M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.42M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     327.80M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     366.97M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     366.96M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.13G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.13G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.13G  126             del x3                                                                         
       4.12G         16.13G  127             del x4                                                                         
       4.12G         16.13G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.13G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.13G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.13G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.13G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.13G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.13G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.13G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.13G   61         C = C.cuda()                                                                                   
       4.11G         16.13G   62         mu = mu.cuda()                                                                                 
       4.11G         16.13G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.13G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.13G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.13G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.13G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.13G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.13G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.13G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.13G   88     u.requires_grad = True                                                                             
       4.11G         16.13G   89     v.requires_grad = True                                                                             
       4.11G         16.13G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.13G   92     for i in range(niter):                                                                             
       4.12G         16.13G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.13G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.13G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.13G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.13G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.13G  103         actual_nits += 1                                                                               
       4.12G         16.13G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.13G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.13G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.13G   19     n = x.size()[0]                                                            
       2.70G         16.13G   20     m = y.size()[0]                                                            
       2.70G         16.13G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.13G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.13G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.13G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.13G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.13G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.13G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.13G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.13G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.13G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.13G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.13G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.13G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## sinkhorn_loss

active_bytes reserved_bytes line code                                                                                                   
         all            all                                                                                                             
        peak           peak                                                                                                             
       2.70G         16.14G   32 @profile_every(1)                                                                                      
                              33 def sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p=2, niter=100, acc=1e-3, unbalanced=False, gpu=True):  
                              34     """                                                                                                
                              35     Given two emprical measures with n points each with locations x and y                              
                              36     outputs an approximation of the OT cost with regularization parameter epsilon                      
                              37     niter is the max. number of steps in sinkhorn loop                                                 
                              38                                                                                                        
                              39     INPUTS:                                                                                            
                              40         x : positions of diracs for the first distribution, torch.FloatTensor of size [n, d]           
                              41         y : positions of diracs for the second distribution, torch.FloatTensor of size [m, d]          
                              42         epsilon : importance of the entropic regularization                                            
                              43         mu : mass located at each dirac, torch.FloatTensor of size [n]                                 
                              44         nu : mass located at each dirac, torch.FloatTensor of size [m]                                 
                              45         n : total number of diracs of the first distribution                                           
                              46         m : total number of diracs of the second distribution                                          
                              47         niter : maximum number of Sinkhorn iterations                                                  
                              48         acc : required accuracy to satisfy convergence                                                 
                              49         unbalanced : specify if unbalanced OT needs to be solved                                       
                              50         gpu : specify usage of CUDA with pytorch                                                       
                              51                                                                                                        
                              52     OUTPUTs:                                                                                           
                              53         cost : the cost of moving from distribution x to y                                             
                              54     """                                                                                                
                              55     # The Sinkhorn algorithm takes as input three variables :                                          
                              56     # C = Variable(cost_matrix(x, y, p=p), requires_grad=True)  # Wasserstein cost function            
       4.81G         16.14G   57     C= cost_matrix(x, y, p=p)                                                                          
                              58                                                                                                        
                              59     # use GPU if asked to                                                                              
       4.11G         16.14G   60     if (gpu & torch.cuda.is_available()):                                                              
       4.11G         16.14G   61         C = C.cuda()                                                                                   
       4.11G         16.14G   62         mu = mu.cuda()                                                                                 
       4.11G         16.14G   63         nu = nu.cuda()                                                                                 
                              64                                                                                                        
                              65     # Parameters of the Sinkhorn algorithm.                                                            
       4.11G         16.14G   66     tau = -.8  # nesterov-like acceleration                                                            
       4.11G         16.14G   67     thresh = acc  # stopping criterion                                                                 
       4.11G         16.14G   68     if (unbalanced):                                                                                   
                              69         rho = 1(.5) ** 2  # unbalanced transport                                                       
                              70         lam = rho / (rho + epsilon)  # Update exponent                                                 
                              71                                                                                                        
                              72     # Elementary operations .....................................................................      
       4.11G         16.14G   73     def ave(u, u1):                                                                                    
                              74         "Barycenter subroutine, used by kinetic acceleration through extrapolation."                   
                              75         return tau * u + (1 - tau) * u1                                                                
                              76                                                                                                        
       4.11G         16.14G   77     def M(u, v):                                                                                       
                              78         "Modified cost for logarithmic updates"                                                        
                              79         "$M_{ij} = (-c_{ij} + u_i + v_j) / \epsilon$"                                                  
                              80         return (-C + u.repeat(m, 1).transpose(0, 1) + v.repeat(n, 1)) / epsilon                        
                              81                                                                                                        
       4.11G         16.14G   82     def lse(A):                                                                                        
                              83         "log-sum-exp"                                                                                  
                              84         return torch.log(torch.exp(A).sum(1, keepdim=True) + 1e-6)  # add 10^-6 to prevent NaN         
                              85                                                                                                        
                              86     # Actual Sinkhorn loop ......................................................................      
       4.11G         16.14G   87     u, v, err = torch.zeros_like(mu), torch.zeros_like(nu), 0.                                         
       4.11G         16.14G   88     u.requires_grad = True                                                                             
       4.11G         16.14G   89     v.requires_grad = True                                                                             
       4.11G         16.14G   90     actual_nits = 0  # to check if algorithm terminates because of threshold or max iterations reached 
                              91                                                                                                        
       4.12G         16.14G   92     for i in range(niter):                                                                             
       4.12G         16.14G   93         u1 = u  # useful to check the update                                                           
       4.12G         16.14G   94         if (unbalanced):                                                                               
                              95             # accelerated unbalanced iterations                                                        
                              96             u = ave(u, lam * (epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u))                 
                              97             v = ave(v, lam * (epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v))             
                              98         else:                                                                                          
       4.12G         16.14G   99             u = epsilon * (torch.log(mu) - lse(M(u, v)).squeeze()) + u                                 
       4.13G         16.14G  100             v = epsilon * (torch.log(nu) - lse(M(u, v).t()).squeeze()) + v                             
       4.12G         16.14G  101         err = (u - u1).abs().sum()                                                                     
                             102                                                                                                        
       4.12G         16.14G  103         actual_nits += 1                                                                               
       4.12G         16.14G  104         if (err < thresh).data.cpu().numpy():                                                          
                             105             break                                                                                      
       4.12G         16.14G  106     U, V = u, v                                                                                        
       4.13G         16.14G  107     pi = torch.exp(M(U, V))  # Transport plan pi = diag(a)*K*diag(b)                                   
       4.13G         16.14G  108     cost = torch.sum(pi * C)  # Sinkhorn cost                                                          
                             109                                                                                                        
       4.12G         16.14G  110     return cost                                                                                        
## sinkhorn_loss_default

active_bytes reserved_bytes line code                                                                           
         all            all                                                                                     
        peak           peak                                                                                     
       2.70G         16.14G   17 @profile_every(1)                                                              
                              18 def sinkhorn_loss_default(x, y, epsilon=0.01, p=2, niter=100, gpu=True):       
       2.70G         16.14G   19     n = x.size()[0]                                                            
       2.70G         16.14G   20     m = y.size()[0]                                                            
       2.70G         16.14G   21     mu = torch.ones(n)/n                                                       
       2.70G         16.14G   22     nu = torch.ones(m)/m                                                       
       4.81G         16.14G   23     return sinkhorn_loss(x, y, epsilon, mu, nu, n, m, p, niter=niter, gpu=gpu) 
## Coarsening.forward

active_bytes reserved_bytes line code                                                                                       
         all            all                                                                                                 
        peak           peak                                                                                                 
     304.82M         16.14G  107     @profile_every(1)                                                                      
                             108     def forward(self, data, epsilon=0.01, opt_epochs=100, p=2):                            
     304.82M         16.14G  109         x, adj, mask = data.x, data.adj, data.mask                                         
     304.83M         16.14G  110         batch_num_nodes = data.mask.sum(-1)                                                
     328.21M         16.14G  111         x1 = F.relu(self.embed_block1(x, adj, mask, add_loop=True))                        
                             112         # xs = [x1.mean(dim=1)]                                                            
     367.38M         16.14G  113         coarse_x, new_adj, S = self.coarse_block1(x1, adj, batch_num_nodes)                
     367.37M         16.14G  114         xs = [coarse_x.mean(dim=1)]                                                        
     408.77M         16.14G  115         x2 = F.tanh(self.embed_block2(coarse_x, new_adj, mask, add_loop=True))             
     402.26M         16.14G  116         xs.append(x2.mean(dim=1))                                                          
                             117                                                                                            
     402.26M         16.14G  118         opt_loss = 0.0                                                                     
       4.12G         16.14G  119         for i in range(len(x)):                                                            
       2.70G         16.14G  120             x3 = self.get_nonzero_rows(x[i])                                               
       2.70G         16.14G  121             x4 = self.get_nonzero_rows(x2[i])                                              
                             122             # if x3.size()[0]==0 or x4.size()[0]==0:                                       
                             123             #     continue                                                                 
                             124             # opt_loss += sinkhorn_loss_default(x3, x4, epsilon, niter=opt_epochs).float() 
       4.81G         16.14G  125             opt_loss += sinkhorn_loss_default(x3, x2[i], epsilon, niter=opt_epochs, p=p)   
       4.12G         16.14G  126             del x3                                                                         
       4.12G         16.14G  127             del x4                                                                         
       4.12G         16.14G  128         return xs, new_adj, S, opt_loss                                                    
